# SRT Protocol — Interactive Simulation Guide

## Overview

The **SRT Protocol Interactive Simulation** (`srt-simulation.html`) is a single-file HTML/JavaScript application that visually demonstrates three core mechanisms of the SRT (Secure Reliable Transport) protocol:

| Tab | What It Demonstrates |
|-----|---------------------|
| **TSBPD Packet Delivery** | How packets travel from Sender through a lossy network into the TSBPD buffer and get delivered to the Receiver with original timing restored |
| **ARQ Retransmission** | The NAK-based selective repeat cycle: gap detection, NAK, retransmission, recovery or TLPKTDROP |
| **Clock Drift** | How sender/receiver clock skew causes buffer drain or overflow, and how SRT's drift correction stabilises it |

The file has **zero dependencies** — just open it in any modern browser. It can be embedded in Confluence via an HTML macro or iframe.

---

## Tab 1: TSBPD Packet Delivery

### What Is TSBPD?

**Timestamp-Based Packet Delivery** is what turns SRT from "a retransmission protocol" into "a broadcast-quality transport." Every packet the sender emits carries a microsecond timestamp. The receiver does not hand packets to the application the moment they arrive — instead it holds them in a **latency buffer** and delivers each one at exactly:

```
delivery_time = packet_timestamp + SRT_latency_setting
```

This reconstructs the sender's original packet cadence, absorbing all network jitter.

### What the Simulation Shows

Packets flow left to right through four zones:

```
SENDER → NETWORK (jitter + loss) → TSBPD BUFFER → RECEIVER
```

- **Teal packets** — normal, delivered successfully
- **Yellow packets** — sitting in the TSBPD buffer, waiting for their scheduled delivery time
- **Red packets** — lost in the network (fade out mid-transit)
- **Purple packets** — retransmitted by the sender after NAK, travelling the full path again
- **Grey packets** — arrived too late, dropped by TLPKTDROP

### Step-by-Step Annotations (Lost Packet Recovery)

When a packet is lost, the simulation shows each stage with on-screen text:

1. **"Pkt #N lost in network"** (red) — the red packet fades out in the network zone
2. **"Receiver detects gap (#N)"** (yellow) — appears near the receiver side
3. **"NAK #N to sender"** (yellow) — slides from receiver toward sender over 1.8 seconds
4. **"Sender received NAK for #N from Receiver"** (yellow) — appears near the sender
5. **"Retransmitting #N"** (purple) — new purple packet leaves the sender
6. **"Retransmit #N in transit"** (purple) — purple packet crosses the network
7. Packet enters the buffer and is delivered — **or** if latency is too low:
   - **"Retransmit #N arrived TOO LATE — DROPPED (TLPKTDROP)"** (red)
   - **"Deadline passed: pkt_timestamp + latency (Xms) already expired"** (red)

### TLPKTDROP in TSBPD

The too-late decision is based on whether the full NAK cycle can complete within the latency budget:

```
Assumed RTT = 60ms
NAK cycle cost = RTT x 2.5 = 150ms  (gap detection + NAK flight + retransmit flight)

If NAK_cycle_cost > latency_setting → TLPKTDROP (too late)
If NAK_cycle_cost < latency_setting → Recovered (in time)
```

**Try it:** Drag the **Latency slider below 100ms** to see retransmits get dropped. Raise it above 200ms to see them recover.

### Controls

| Control | Range | Default | Effect |
|---------|-------|---------|--------|
| SRT Latency | 20–500 ms | 120 ms | Size of the TSBPD buffer; higher = more time for recovery but more delay |
| Network Jitter | 0–150 ms | 40 ms | Randomness in packet arrival times |
| Packet Loss % | 0–30% | 10% | Probability of a packet being lost in the network |
| Packet Rate | 1–15 pkt/s | 3 pkt/s | How often new packets are spawned |

### Stats

| Stat | Meaning |
|------|---------|
| Packets Sent | Total packets generated by the sender |
| Delivered OK | Packets that made it to the receiver on time |
| Recovered (ARQ) | Lost packets successfully retransmitted and delivered |
| Dropped (Too Late) | Lost packets where retransmit missed the TSBPD deadline |
| Buffer Fill | Current buffer occupancy as a percentage (green < 60% < yellow < 90% < red) |
| Effective Loss | `(dropped / sent) x 100` — the actual loss the application sees |

---

## Tab 2: ARQ Retransmission

### What Is ARQ?

SRT uses **NAK-based Selective Repeat ARQ**. Unlike TCP which acknowledges every received packet (ACK-based), SRT's receiver only speaks up when something is **missing** — it sends a **NAK (Negative Acknowledgement)**. This is more efficient for real-time streams because:

- No ACK overhead for the 95%+ of packets that arrive fine
- The sender retransmits only the specific missing packets, not everything after the gap

### What the Simulation Shows

A sequence diagram with two vertical lifelines:

```
SENDER                          RECEIVER
  |                                |
  |-------- Pkt #1 ------------->| ✓ Delivered
  |-------- Pkt #2 -----X       | LOST
  |                      Receiver detects gap (#2)
  |<------- NAK #2 -------------|
  |  Sender received NAK for #2 from Receiver
  |-------- R2 (retransmit) --->| ✓ RECOVERED
  |                                |
```

Each row represents one packet. Lost packets trigger the full NAK/retransmit cycle with animated arrows and annotations.

### Step-by-Step Annotations

Every packet gets a text label at each stage:

| State | Annotation | Colour |
|-------|-----------|--------|
| Packet flying | (packet pill with sequence number) | Teal or Red |
| Lost in network | **"Pkt #N lost in network"** | Red |
| Delivered normally | **"Pkt #N delivered to Receiver"** | Teal |
| Gap detected | **"Receiver detects gap (#N)"** | Yellow |
| NAK in flight | **"NAK #N sent to Sender from Receiver"** | Yellow |
| NAK arrived | **"Sender received NAK for #N from Receiver"** | Yellow |
| Retransmit in flight | **"Sender retransmits #N → Receiver"** | Purple |
| Recovery successful | **"✓ RECOVERED"** | Purple |
| Too late | **"TOO LATE — DROPPED (TLPKTDROP)"** | Red |

### Time-Scaling: How RTT Affects Recovery

The visual animation always takes the same time (2.5 seconds per flight), but the **RTT slider controls whether recovery is mathematically possible** via a time-scaling formula:

```
realTime = visualTime × (RTT / 2) / FLIGHT_MS

Where:
  visualTime = elapsed animation time in ms
  RTT        = Round-Trip Time from slider (ms)
  FLIGHT_MS  = 2500 (visual flight constant)
```

**Example — RTT = 60ms, Latency = 200ms:**

```
Full NAK cycle visual time = ~7500ms (3 flights + delays)
Real time = 7500 × (60/2) / 2500 = 7500 × 30 / 2500 = 90ms
90ms < 200ms latency → RECOVERED ✓
```

**Example — RTT = 300ms, Latency = 200ms:**

```
Real time = 7500 × (300/2) / 2500 = 7500 × 150 / 2500 = 450ms
450ms > 200ms latency → TOO LATE ✗
```

This is why the **Latency/RTT ratio** shown in the footer matters:

| Ratio | Meaning |
|-------|---------|
| ≥ 4x | **Good** — room for multiple retransmit attempts |
| 2–4x | **Tight** — one retransmit attempt may succeed |
| < 2x | **Too low** — no time to recover, most lost packets are dropped |

### Latency Budget Bar

Each lost packet shows a thin progress bar at the bottom of its row:

```
[████████████░░░░░░░░░░] budget 65%
 green        yellow    red
```

This fills up in real-time showing how much of the latency budget has been consumed. When it reaches 100%, the packet is dropped.

### Controls

| Control | Range | Default | Effect |
|---------|-------|---------|--------|
| RTT (Round-Trip Time) | 10–300 ms | 60 ms | Network round-trip; higher = less time for retransmission |
| SRT Latency | 40–600 ms | 200 ms | TSBPD deadline; higher = more recovery room but more delay |
| Packet Loss % | 0–30% | 5% | Probability of loss; higher = more NAK/retransmit cycles visible |

### Stats

| Stat | Meaning |
|------|---------|
| Packets Sent | Total data packets sent by sender |
| Lost in Transit | Packets lost in the network |
| NAKs Sent | NAK messages sent by receiver |
| Recovered | Lost packets successfully recovered via retransmission |
| Too Late (Dropped) | Retransmits that missed the TSBPD deadline |
| Latency / RTT Ratio | `latency / RTT` — the key indicator of recovery capacity |

---

## Tab 3: Clock Drift

### What Is Clock Drift?

Every device has a quartz crystal oscillator as its clock source. No two crystals are identical — they differ by a few **parts per million (ppm)**. Over minutes and hours, this tiny difference accumulates:

```
100 ppm = 0.1 ms drift per second = 6 ms per minute = 360 ms per hour
```

Without correction, the TSBPD buffer either **drains** (fast receiver clock) or **overflows** (slow receiver clock).

### What the Simulation Shows

A real-time graph plotting the **TSBPD buffer fill level** over simulated time:

```
Buffer Fill (ms)
  360 |                                           ← Overflow zone
      |
  240 |
      |
  120 |─ ─ ─ ─ ─ ─ ─ ─ ─ ─ Target (latency) ─ ─ ─
      |
    0 |___________________________________________  ← Underrun zone
      0:00    1:00    2:00    3:00    4:00    5:00
                     Simulated Time
```

- **Teal line** — buffer fill level (no correction)
- **Purple line** — buffer fill level (with drift correction ON)
- **Yellow dashed line** — target buffer level (= latency setting)
- **Red zones** — overflow (top) and underrun (bottom) danger areas

### How Drift Is Calculated

Each animation frame:

```
drift_this_frame = (ppm / 1,000,000) × simulated_time_elapsed

effective_buffer = latency - accumulated_clock_offset
```

- **Positive ppm (fast clock):** Receiver plays out packets faster than sender sends them → buffer shrinks → **UNDERRUN** (audio/video glitch)
- **Negative ppm (slow clock):** Receiver plays out slower → buffer grows → **OVERFLOW** (buffer full, packets discarded)

### Drift Correction

When **Drift Correction = ON**, SRT applies exponential convergence:

```
clockOffset = clockOffset × 0.97   (each frame)
```

This removes 3% of the remaining offset each frame, smoothly pulling the buffer back to the target level. In real SRT, the receiver measures drift by comparing sender timestamps against its own clock, then adjusts the TSBPD delivery schedule by tiny amounts (microseconds) each packet.

**Try it:**
1. Start with **Correction OFF** and **+100 ppm** — watch the buffer drain to zero (UNDERRUN)
2. Hit **Reset**, turn **Correction ON** — watch the buffer stabilise around the target line
3. Try **-200 ppm** with Correction OFF to see OVERFLOW

### Controls

| Control | Range | Default | Effect |
|---------|-------|---------|--------|
| Clock Drift (ppm) | -200 to +200 | +100 (fast) | Crystal frequency difference; positive = fast receiver, negative = slow |
| SRT Latency | 40–400 ms | 120 ms | Target buffer level; higher = more margin before underrun/overflow |
| Drift Correction | OFF / ON | OFF | Toggles SRT's drift compensation algorithm |
| Speed (simulation) | 1x–50x | 3x | How fast simulated time passes; higher = see drift effects sooner |

### Stats

| Stat | Meaning |
|------|---------|
| Elapsed Time | Simulated time in M:SS format |
| Clock Offset | Accumulated drift in ms (+ = fast, − = slow) |
| Buffer Fill | Current effective buffer level in ms |
| Correction Applied | "Active" or "Off" |
| Status | OK / WARNING / UNDERRUN / OVERFLOW |

### Status Thresholds

| Status | Condition |
|--------|-----------|
| **OK** | Buffer between 30% and 200% of latency |
| **WARNING** | Buffer below 30% or above 200% of latency |
| **UNDERRUN** | Buffer ≤ 0 ms (receiver starved) |
| **OVERFLOW** | Buffer ≥ 250% of latency (receiver overwhelmed) |

---

## How the Three Tabs Relate

The three simulations demonstrate interconnected SRT mechanisms:

```
                    ┌─────────────────────────────────────┐
                    │         SRT Protocol Stack          │
                    │                                     │
                    │  ┌───────────┐  ┌────────────────┐  │
                    │  │    ARQ    │  │     TSBPD      │  │
                    │  │ (Tab 2)   │  │    (Tab 1)     │  │
                    │  │           │  │                │  │
                    │  │ Detects   │  │ Holds packets  │  │
                    │  │ loss →    │  │ in latency     │  │
                    │  │ NAK →     │→ │ buffer →       │  │
                    │  │ Retransmit│  │ delivers at    │  │
                    │  │           │  │ correct time   │  │
                    │  └───────────┘  └────────────────┘  │
                    │                        ↑            │
                    │                 ┌──────┴─────────┐  │
                    │                 │  Clock Drift   │  │
                    │                 │   Correction   │  │
                    │                 │   (Tab 3)      │  │
                    │                 │                │  │
                    │                 │ Keeps buffer   │  │
                    │                 │ stable despite │  │
                    │                 │ crystal skew   │  │
                    │                 └────────────────┘  │
                    └─────────────────────────────────────┘
```

1. **ARQ** recovers lost packets by retransmission
2. **TSBPD** absorbs jitter and reorders packets, delivering them at the original cadence
3. **Clock Drift Correction** prevents the TSBPD buffer from draining or overflowing over long sessions

Together, they enable SRT to deliver broadcast-quality video over unpredictable networks.

---

## Key SRT Concepts Demonstrated

### TLPKTDROP (Too-Late Packet Drop)

Both the TSBPD and ARQ tabs demonstrate TLPKTDROP — SRT's decision to **discard a packet rather than deliver it late**. For live video, a late frame causes the decoder to stall, which is worse than a brief glitch from a missing frame. The deadline is:

```
deadline = packet_timestamp + latency_setting
```

If a packet (original or retransmitted) hasn't arrived by this time, it is dropped.

### The Latency/RTT Tradeoff

The ARQ tab clearly shows the fundamental SRT tradeoff:

- **Higher latency** = more time for retransmission = lower effective loss = more end-to-end delay
- **Lower latency** = less recovery time = higher effective loss = lower delay

The **Latency/RTT ratio** is the key metric:
- A ratio of **4x or higher** is recommended for reliable recovery
- Below **2x**, most lost packets cannot be recovered

### NAK-Based vs ACK-Based

SRT uses **NAK-based** feedback (receiver reports what's missing) rather than TCP's **ACK-based** feedback (receiver reports what arrived). This is visible in the ARQ tab:
- Only lost packets trigger NAK messages
- Successfully delivered packets show a checkmark but generate no return traffic
- This reduces overhead, which matters for high-bitrate video streams

---

## Embedding in Confluence

### Option 1: HTML Macro (Confluence Server/Data Center)

If your Confluence instance has the HTML macro enabled:

1. Edit the page → Insert → Other macros → HTML
2. Paste the entire contents of `srt-simulation.html`
3. Save

### Option 2: Iframe (Confluence Cloud or Server)

1. Host the file on an internal web server or S3 bucket
2. Insert an iframe macro pointing to the hosted URL:
   ```
   <iframe src="https://your-host/srt-simulation.html" width="100%" height="900" frameborder="0"></iframe>
   ```

### Option 3: Confluence Attachment + Redirect

1. Attach `srt-simulation.html` to the Confluence page
2. Link to the attachment — it opens in a new browser tab as a standalone page

---

## Technical Details

### Animation Timing Constants

| Constant | TSBPD Tab | ARQ Tab |
|----------|-----------|---------|
| Packet flight time | ~1000ms (sender→network), ~4000ms (network transit) | 2500ms per one-way flight |
| NAK delay | N/A (annotations: 1s + 1.8s + 1.2s) | 800ms |
| Spawn interval | 1000 / rate (default: ~333ms) | 4000ms |
| Retransmit send phase | 1000ms | (same as flight: 2500ms) |
| Buffer dwell time | latency × 25 ms | N/A |
| Delivery phase | 1000ms | N/A |

### Canvas Rendering

- All three tabs use HTML5 Canvas with `devicePixelRatio` scaling for crisp rendering on Retina/HiDPI displays
- Canvases auto-resize on window resize and tab switch
- Each simulation runs its own independent `requestAnimationFrame` loop

### File Size

The entire simulation is a single `srt-simulation.html` file with no external dependencies — HTML, CSS, and JavaScript are all inline. This makes it portable and easy to host or share.
